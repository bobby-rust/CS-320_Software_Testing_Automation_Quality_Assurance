# CS-320_Software_Testing
## How can I ensure that my code, program, or software is functional and secure?
To ensure that any piece of software is functional and secure, it needs to be tested and proven to be. Manually reviewing software for bugs is helpful, but people won't catch every bug. Writing tests that verify that the piece of software meets its requirements is essential to writing quality software. Having a destructive mindset and attempting to break the code and stress test it can ensure that faulty or incompetent software is recognized. Being pessimistic and assuming that all software has bugs is both virtually true and helpful. Writing test cases that use the software in ways in which it wasn't meant to be used is crucial, especially for user-facing code and APIs and libraries that will be used by other developers. Once the code is in use, you don't know who will be using it and what their knowledge of how to use the system will be, so you have to expect that they will use it improperly, and the software should be resilient to improper use.
## How do I interpret user needs and incorporate them into a program?
Interpreting user needs begins with understanding the user and their use case for the software. Requirements gathering involves speaking to users directly and observing them using the software. These requirements can then be analyzed and placed into groups or combined and reduced to simpler requirements. Once these requirements are known and documented, the system can be designed, implemented, and tested. User acceptance testing can be done to validate that the program meets the end-user's requirements.
## How do I approach designing software?
I approach designing software in much the same steps as interpreting user needs and incorporating them. First I need to understand the problem that needs to be solved. This can be tricky and surprisingly complex, so this shouldn't be rushed through. Once the problem space is understood, I can then begin brainstorming solutions. These solutions can be analyzed for feasibility, efficiency, and comprehensiveness. While analyzing, a solution can be picked or new solutions can be thought of through realizing the downfalls of the initial solutions. Once the solution is ready, the system can be designed at a high level, using relevant design patterns as needed so the system is as simple, maintainable, and efficient as possible. 
